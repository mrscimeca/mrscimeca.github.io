<!DOCTYPE html> 
<html>
  <head>
  
    <script src="https://cdn.jsdelivr.net/npm/p5@1.1.9/lib/p5.js"></script>
	<script src="https://cdn.jsdelivr.net/pyodide/v0.18.1/full/pyodide.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/p5@1.0.0/lib/p5.js"></script>

    <link rel="stylesheet" type="text/css" href="style.css">
    <meta charset="utf-8">
	
  <link rel="stylesheet"type="text/css" href="new-1.css">  
  </head>
  
  <body>
    <h1>Black holes</h1>
    
    
    <ul>

      <a href="index.html"><li>Home</li></a>
      <a href="Info.html"><li>Info</li></a>
      <a href="Images.html"><li>Images</li></a>
      <a href="Types.html"><li>Types</li></a>
      <a href="Facts.html"><li>Facts</li></a>
    
    </ul>
<p>black holes are dangores things in space science can't explane them the only thing they can explane. is the outside of them but science has a problem explaneing the inside of a black hole. nowone knows what is inside a black hole. the one fact science knows is not even the fastist thing in existens light can escape a black hole!</p>       
    
<img src="ghcfgv.jpg">
    
<img src="hello.jpg" style="width:100%;">
       
     <img  src="hi.png" style="width:100%;">
  <img src="dd.jpg">  
  <img src="1219_earth_cc---Copy.jpg" style="width:100%;">  
    
    
    


 
    <script>

    function setup() {
      createCanvas(400, 400);
    }
    //variables for pumpkin
    var pmk = {
        x:185,
        y:286,
        w:204,
        h:182,
        inx:0,
        iny:0
        };

    var eye = {
      x:-11,
      y:-36,
      w:-5,
      h: 6,
      dis:-99
    };

    var mouth = {
      x:0,
      y:0,
      w:0,
      h: 0


    };

    //flicker function(turned off)
    var flic;
    var eyec = [255, 0, 0, 163, 10, 10,255, 191, 0,161, 124, 11];
    var eyefi = [];
    var eyefo = [];

    //button class
    var Bttn = function(x,y,w,h,txt){
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
        this.txt = txt;

    };
    //buttons
    var wbutton = new Bttn(136,8,75,27,"Width");
    var hbutton = new Bttn(136, 35, 75, 27, "Height");
    var ewbutton = new Bttn(136, 62, 75, 27, "Eye Dis.");


    Bttn.prototype.draw = function(){

      fill(67, 247, 57);
      rect(this.x,this.y,this.w,this.h);

      fill(0, 0, 0);
      text(this.txt,this.x+18,this.y+17);
    };

    var check_button = function(bttn){
       if (mouseX>bttn.x&&mouseX<bttn.x+bttn.w&&mouseY>bttn.y&&mouseY<bttn.y+bttn.h){
             return true;
         }
    };
    var flicker = function(){


        if (random(100)>100){
            flic = false;

        }else{flic = true;}

        if (flic === true){
            eyefi = [eyec[0],eyec[1],eyec[2]];
            eyefo = [eyec[3],eyec[4],eyec[5]];

        } else {
            eyefi = [eyec[6],eyec[7],eyec[8]];
            eyefo = [eyec[9],eyec[10],eyec[1]];

        }

    };

    //parts of the pumk
    var build_mouth = function(x, y, w, h){
      fill(255, 0, 0);
      beginShape();
        vertex(0+x+w, 0+y-h);       //top left

        vertex(51+x+w, 22+y-h);     //first tooth down
        vertex(85+x+w, 8+y-h);

        vertex(128+x+w, 22+y-h);    //second tooth down

        vertex(200+x+w, 0+y-h);     //top right
        vertex(180+x+w, 50+y-h);    //bottom right

        vertex(164+x+w, 33+y-h);    //first tooth up
        vertex(136+x+w, 50+y-h);

        vertex(90+x+w, 33+y-h);    //second tooth up
        vertex(57+x+w, 50+y-h);

        vertex(32+x+w, 33+y-h);    //third tooth up
        vertex(23+x+w, 50+y-h);

        vertex(20+x+w, 50+y-h);     //bottom left
      endShape(CLOSE);

};
    var build_eye= function(x,y,w,h,eyex, eyey,eyew, eyeh, eyed,flic){



         //pmk eye left
        fill(eyefi[0],eyefi[1],eyefi[2]);
        triangle(
            x +1 + eyex +eyew-eyed, y+16 + eyey +eyeh,
            x -84 + eyex-eyew-eyed, y+20+ eyey+eyeh,
            x -47 + eyex-eyed, y+-37+ eyey-eyeh
            );

        fill(eyefo[0],eyefo[1],eyefo[2]);
        quad(
            x +-91+ eyex-eyew-eyed, y+23+ eyey+eyeh,
            x-84+ eyex-eyew-eyed, y+20+ eyey+eyeh,
            x+-47+ eyex-eyed, y+-37+ eyey-eyeh,
            x +-53+ eyex-eyed, y+-44+ eyey-eyeh
            );

        quad(
            x +13+ eyex+eyew-eyed, y+23+ eyey+eyeh,
            x-1+ eyex+eyew-eyed, y+16+ eyey+eyeh,
            x+-56+ eyex-eyed, y+-37+ eyey-eyeh,
            x +-53+ eyex-eyed, y+-44+ eyey-eyeh
            );



        //pmk eye right
        fill(eyefi[0],eyefi[1],eyefi[2]);
        triangle(
            x -1+ eyex -eyew+eyed, y+16+ eyey+eyeh,
            x+84+ eyex +eyew+eyed, y+20+ eyey+eyeh,
            x+47+ eyex+eyed, y+-37+ eyey-eyeh
            );

        fill(eyefo[0],eyefo[1],eyefo[2]);
        quad(
            x + 91 + eyex + eyew +eyed, y + 23 + eyey +eyeh,
            x + 84 + eyex + eyew +eyed, y + 20 + eyey + eyeh,
            x + 47 + eyex + eyed, y - 37 + eyey - eyeh,
            x + 53 + eyex + eyed, y - 44 + eyey - eyeh
            );

        quad(
            x -13+ eyex-eyew+eyed, y+23+ eyey+eyeh,
            x+1+ eyex-eyew+eyed, y+16+ eyey+eyeh,
            x+56+ eyex+eyed, y+-37+ eyey-eyeh,
            x +53+ eyex+eyed, y+-44+ eyey-eyeh
            );


    };
    var build_stem = function(x, y, w, h){
      //build stem
        var sx;
        var sy;

        sx = x-30;
        sy = y-140;

        fill(18, 61, 9);

        quad(10+sx, 10+sy,
        30+sx, 15+sy,
        30+sx, 70+sy,
        20+sx, 70+sy);


        fill(13, 43, 6);

        quad(51+sx, 10+sy,
        30+sx, 15+sy,
        30+sx, 70+sy,
        37+sx, 70+sy);


          fill(57, 120, 43);

           quad(51+sx, 10+sy,
        30+sx, 15+sy,
        10+sx, 10+sy,
        37+sx, 5+sy);

    };
    var build_pmk = function() {


      //build pmk
      strokeWeight(1);

      //left
      fill(217, 130, 0);
      ellipse(pmk.x - 45 + (pmk.inx/8), pmk.y, pmk.w, pmk.h);

      //highlight
      fill(242, 215, 172, 90);
      arc(pmk.x - 45 + (pmk.inx/8), pmk.y, pmk.w, pmk.h, 10, 170);
      //left shadow
      fill(0, 0, 0, 90);
      noStroke();
      ellipse(pmk.x - 10 + (pmk.inx/8), pmk.y + 10, pmk.w - 3, pmk.h + 10);

      //right
      stroke(0, 0, 0);
      fill(217, 130, 0);
      ellipse(pmk.x + 45 + (pmk.inx/8), pmk.y, pmk.w, pmk.h);

      //highlight
      fill(242, 215, 172, 90);
      arc(pmk.x + 45 + (pmk.inx/8), pmk.y, pmk.w, pmk.h, 10, 170);
      //right shadow
      fill(0, 0, 0, 90);
      noStroke();
      ellipse(pmk.x + 12 + (pmk.inx/8), pmk.y + 10, pmk.w - 3, pmk.h + 10);

      //middle circle
      stroke(0, 0, 0);
      fill(217, 130, 0);
      ellipse(pmk.x + (pmk.inx/4), pmk.y, pmk.w, pmk.h);

      //highlight
      fill(242, 215, 172, 90);
      arc(pmk.x + (pmk.inx/4), pmk.y, pmk.w, pmk.h, 10, 170);

      //middle circle shadow
      fill(0, 0, 0, 90);
      noStroke();
      ellipse(pmk.x + (pmk.inx/4), pmk.y + 10, pmk.w - 69, pmk.h + 10);
      stroke(0, 0, 0);
      fill(217, 130, 0);


      //mid mid
      ellipse(pmk.x + (pmk.inx/2), pmk.y, pmk.w / 2, pmk.h);

      //highlight
      fill(242, 215, 172, 90);
      arc(pmk.x + (pmk.inx/2), pmk.y, pmk.w / 2, pmk.h, 10, 170);


      //pmk shadow
      fill(0, 0, 0, 90);
      noStroke();
      ellipse(pmk.x + -5, pmk.y + 101, pmk.w + 124, pmk.h + -105);
    };

    //pumk
    var pumpkin = function(x,y,w,h){
        flicker(flic);
        build_stem(x,y,w,h);
        build_pmk(x,y,w,h);
        build_eye(x,y,w,h,eye.x, eye.y,eye.w,eye.h,eye.dis);
        build_mouth(mouth.x + 78,mouth.y + 334,mouth.w + 7,mouth.h + 0);
    };


    mouseDragged = function(){
        if (check_button(wbutton)){
            wbutton.x = mouseX-wbutton.w/2;
            pmk.w = wbutton.x/2+120;

        }
         if (check_button(hbutton)){
            hbutton.x = mouseX-hbutton.w/2;
            pmk.h = hbutton.x/4+150;

        }
         if (check_button(ewbutton)){
            ewbutton.x = mouseX-ewbutton.w/2;
            eye.dis = ewbutton.x/6-129;

        }
    };

    mouseMoved = function(){
      eye.x = mouseX/5-40;
      eye.y = mouseY/5-60;
      pmk.inx = (mouseX - 200)/8;
      mouth.x = mouseX/5-40;
      mouth.y = mouseY/6-60;
      //pmk.iny = (mouseY - 286)/8;

    };

    draw = function() {
         background(0, 0, 0);
         pumpkin(pmk.x,pmk.y,pmk.w,pmk.h);
        wbutton.draw();
        hbutton.draw();
        ewbutton.draw();

    };














    </script>
	
	<pre><code># Inspired by Mats Lund:
# https://github.com/CoderMats/breakout 
# Completely rewritten

WIDTH =  640    # canvas width
HEIGHT = 400    # canvas height
P_WIDTH =  50   # paddle halfwidth
P_HEIGHT = 8    # paddle halfheight
B_ROWS = 5      # bricks, number of rows
B_COLS = 10     # bricks, number of columns
B_MARGINS = 15  # margins for bricks (bottom, side)
BALL_DIAM = 10  # diameter of ball
FPS = 30        # frames per second

# block width, height, total space
b_width = (WIDTH - 2 * B_MARGINS) // B_COLS
b_height = 40  
b_gap = 15      # gap between blocks

# constants, helper variables
bw2 = b_width // 2 
bh2 = b_height // 2
dw = (b_width - b_gap) // 2
dh = (b_height - b_gap) // 2
r = BALL_DIAM // 2    # ball diameter
y_paddle = HEIGHT - 30

cell_colors = {1:"green" , 2:"blue" , 3:"red" , 4:"yellow"}

game = None

def setup():
    global game
    createCanvas(WIDTH, HEIGHT, P2D)
    rectMode(CENTER)
    frameRate(FPS)
    noCursor()
    game = Game()

def new_game():
    global game
    new_level = game.level + int(game.blocks_gone)
    game = Game(level=new_level)
        
def draw():
    global game
    if game.blocks_gone:
        new_game()    
    if not game.game_over:
        game.paddle.x = min(WIDTH - P_WIDTH, max(mouseX, P_WIDTH))
    game.update()        

def keyPressed():
    if key == " ":
        new_game()

class Ball(object):
    def __init__(self,level=1):
        # ball velocity
        self.vel = PVector(3 + int(1.5 * level),-3 - int(1.5 * level))
        xp = WIDTH // 2 + int(random(-P_WIDTH - 40,P_WIDTH + 40))
        yp = y_paddle - P_HEIGHT // 2 - r - 1      
        self.pos = PVector(xp,yp)                   # ball position

    def update(self):    
        self.pos = PVector.add(self.pos,self.vel)
        if (self.pos.x >= WIDTH or self.pos.x <= 0):  
            self.vel.x = -self.vel.x
        if (self.pos.y <= 0):
            self.vel.y = -self.vel.y

class Game(object):
    def __init__(self,level=1):
        self.paddle = PVector(WIDTH // 2, HEIGHT - 30)
        self.level = level
        self.ball = Ball()
        self.score = 0 
        self.blocks = [int(random(1.5,4.5)) for k in  range(B_ROWS * B_COLS)]
        self.game_over = False
        self.blocks_gone = False
        # x, y positions of block centers
        self.centers = [((i % B_COLS) * b_width + B_MARGINS + bw2,
                         b_height * (i // B_COLS) + B_MARGINS + bh2) 
                         for i in range(B_ROWS * B_COLS)]

    def update_ball(self):
        self.ball.update()
        px, py = self.paddle.x, self.paddle.y
        if ((px - P_WIDTH -r) <= self.ball.pos.x
             <= (px + P_WIDTH + r) and 
            (py - P_HEIGHT - r <= self.ball.pos.y 
             <= py - P_HEIGHT)):
            # ball is hitting paddle rectangle, reverse y_speed
            self.ball.vel.y = -self.ball.vel.y
            self.score = self.score + 1
        fill(100,100,200)
        ellipse(self.ball.pos.x, self.ball.pos.y, BALL_DIAM, BALL_DIAM)

            
    def update_paddle(self):
        fill(0,255,0)
        rect(self.paddle.x, self.paddle.y, 2 * P_WIDTH, 2* P_HEIGHT)
        if (self.ball.pos.y >= HEIGHT):
            fill(255) 
            textSize(40)
            textAlign(CENTER)
            text("Game over", WIDTH // 2, HEIGHT // 2 + 40)
            self.game_over = True 
    
    def update_texts(self):            
        background(25)
        noStroke()
        # Set fill color to white
        fill(255)
        # Display score
        textSize(16)
        textAlign(RIGHT)
        text("Score", 80, HEIGHT - 6)
        textAlign(LEFT)
        text(self.score, 90, HEIGHT - 6)
        # text("Frames: %.1f" %frameRate(), 130, HEIGHT - 6) 
        # Display level
        textAlign(RIGHT)
        text("Level", WIDTH - 50, HEIGHT - 6)
        textAlign(LEFT)
        text(self.level, WIDTH - 40, HEIGHT - 6)

    def update_blocks(self):
        self.blocks_gone = True
        # Loop through all the potential blocks
        collide = False

        for i in range(B_ROWS * B_COLS):
            # Check if we have that block
            if (self.blocks[i]):
                x_cent, y_cent = self.centers[i]
                self.blocks_gone = False
                    
                if not collide:
                    bx, by = self.ball.pos.x, self.ball.pos.y     
                    # check bounce on top/bottom
                    if ((x_cent - dw - r < bx < x_cent + dw + r) and 
                        ((y_cent + dh < by < y_cent + dh + r) or 
                        (y_cent -dh - r < by < y_cent - dh))):
                        self.blocks[i] = 0
                        self.ball.vel.y = -self.ball.vel.y
                        self.score = self.score + 5
                        collide = True
                     
                    # check bounce on left/right
                    if ((y_cent - dh - r < by < y_cent + dh + r) and 
                        ((x_cent + dw < bx < x_cent + dw + r) or 
                        (x_cent - dw -r < bx < x_cent - dw))):
                        self.blocks[i] = 0
                        self.ball.vel.x = -self.ball.vel.x
                        self.score = self.score + 5
                        collide = True
            if collide:
                break
                    
    def draw_blocks(self):
        for i in range(B_ROWS * B_COLS):
            if (self.blocks[i]):
                fill(cell_colors[self.blocks[i]])
                x_cent, y_cent = self.centers[i]
                rect(x_cent, y_cent, 2 * dw, 2 * dh)
                        
    def update(self):
        self.update_texts()
        self.update_ball()
        self.update_paddle()
        self.update_blocks()    
        self.draw_blocks()
        
                  </code></pre>

 </body>
</html>